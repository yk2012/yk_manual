上一讲我们学习了 Vue 响应式的大致原理，响应式就是可以把普通的 JavaScript 对象包裹成响应式对象，这样，我们对对象做的修改，响应式都能够监听到，并且执行 effect 内部注册的函数来执行数据修改之后的效果。


那今天我就跟你聊一下 Vue 在浏览器里是如何运行的，照例我们还是对着 Vue 3 的源码来学习，不过源码复杂，为了帮助你理解主要逻辑，我会直接把源码简化再演示，当然怎么简化源码的一些小技巧也会顺便分享给你。

好了废话不多说，我们马上开始。前端框架需要处理的最核心的两个流程，就是首次渲染和数据更新后的渲染。先来看首次渲染的源码。演示代码会用 Vue 3 的实际代码，你也可以在 weiyouyi 项目中看到我们课程的 mini 版本代码。

## 首次渲染

我们知道，想要启动一个 Vue 项目，只需要从 Vue 中引入 createApp，传入 App 组件，并且调用 createApp 返回的 App 实例的 mount 方法，就实现了项目的启动。这个时候 Vue 也完成了首次渲染，代码逻辑如下：


所以 createApp 就是项目的初始化渲染入口。

但是这段简单的代码是怎么完成初始化渲染的呢？我们可以在 Vue 中的 runtime-dom 中看到 createApp 的定义，你可以打开 GitHub 链接查看。

这里就有一个看代码的小技巧，分享给你，我们首次查看源码的时候，可以先把一些无用的信息删除，方便自己梳理主体的逻辑。看 Vue 代码，和今天主题无关的无用信息有哪些，__COMPAT__ 代码是用来兼容 Vue 2 的，__DEV__ 代码是用来调试的，我们可以把这些代码删除之后，得到下面的简化版 createApp 源码。


再看思路就比较清晰了。我们使用 ensureRenderer 返回的对象去创建 app，并且重写了 app.mount 方法；在 mount 方法内部，我们查找 mount 传递的 DOM 元素，并且调用 ensureRenderer 返回的 mount 方法，进行初始化渲染。如下图所示：



之前我们讲过要会 TypeScript，这时你就能感受到 TypeScript 的好处了，现在即使我们不知道 app.mount 是什么逻辑，也能知道这个函数的参数只能是 Element、ShadowRoot 或者 string 三者之一，也就很好理解内部的 normalizeContainer 就是把你传递的参数统一变为浏览器的 DOM 元素，Typescript 类型带来的好处，我们在读源码的时候会一直感受得到。




















